# Unreal Objects

> [!IMPORTANT]
> This page is being updated based on some empirical testing, the text within may be inaccurate.

Here's some notes about Unreal's object system.

## UObject

The vast majority of heap-allocated objects within Unreal Engine (and the games built on it) are `UObjects`.
`UObjects` add several features on top of plain C++ objects including introspectability, serializability, 
garbage collection and more. 

UObject classes are created using Unreal's `NewObject()` function, _not `new` and related `std` allocating facilities_.

## Reflection

Unreal's reflection system is enabled by a pre-compilation pass that generates code that represents specially marked 
classes at runtime along with specially marked properties of those classes. To put it another way, Unreal's reflection 
system is _opt in_.

Classes which should be exposed to reflection are marked with the `UCLASS` marker, and properties that should be 
exposed to reflection are marked with the `UPROPERTY` marker. 

When opting in to reflection there are a few requirements which ensure that Unreal's reflection system can inject the 
necessary data to make available at runtime. 
- A reflected class must derive from the `UObject` class
- The header which contains the reflected class declaration must include a header generated by Unreal
- The class declaration must include the `GENERATED_BODY` macro

```cpp
// MyClass.h
// ...[other includes]...
#include "MyClass.generated.h"

UCLASS
class UMyClass: public UObject {
    GENERATED_BODY()
    // ...
};
```

Unreal's build system (UnrealBuildTool) uses a helper called UnrealHeaderTool which is responsible for parsing the 
headers for the `UCLASS`es you define, and generating code which represents elements of these classes which should be 
compiled in to the final module. 

UnrealHeaderTool generates two files for each header that contains `UCLASS`es:
- `<HeaderName>.generated.h` - Provides the declarations which replaces the `GENERATED_BODY` macros, including a means 
  to acquire the generated metadata, which is stored in an instance of the `UClass` class.
- `<HeaderName>.gen.cpp` - Provides the definitions for the `GENERATED_BODY` declarations.

At runtime, you can access the metadata for an instance by calling `GetClass()` which will ultimately return the 
`UClass*` that is provided by the generated code, or call `<ClassName>::StaticClass()` which does the same. Many of 
Unreal's features are built on top of this core reflection system.

Properties marked for reflection (using `UPROPERTY`) must have types that are themselves compatible with the reflection 
system. Not all C++ types are supported. Additionally Unreal's reflection most of Unreal's custom container classes 
(but not all), such as `TArray`, `TMap`, `TSet` etc.

## Class Default Objects (CDOs)

In addition to metadata about functions and properties, UClass provides the ability to obtain the "default" property 
values of a UClass by way of Class Default Objects (CDOs). When Unreal loads a class, one object of the class is 
allocated, running its default constructor. That object is saved for the lifetime of the class (which in the case of 
native C++ classes is for the lifetime of the game/editor process).

That object can be obtained by using `GetDefault<Class>()`. 

## Garbage Collection

Unreal has its own garbage collector which allows objects to be automatically destroyed when they 
are no longer referred to by another object, in a manner similar to the garbage collectors found in high level 
languages like Java, Javascript, C# etc. 

Because the garbage collector is implemented in "user land" (so to speak), and the language and runtime is 
not designed around the expected existence of a garbage collector, only `UObjects` can participate in this system. 
Normal C++ objects (allocated with `new` or other equivalent `std` features) will not be handled by the garbage 
collector.

The reflection information provided above is the core mechanism that allows Unreal's garbage collector to work. The GC 
is able to traverse the properties of an object of a given `UCLASS` by referencing the reflection metadata stored in 
the `UClass*` object associated with the `UObject` in order to build a graph of which objects are reachable (with a 
set of assumed "root" objects that are always considered reachable). Objects which do not appear within the 
reachability graph are considered "dead" and are ultimately destroyed.

In addition to pointers to other `UObject`s, the garbage collector is able to traverse the container types supported 
by Unreal's reflection system such as `TArray`, `TMap`, `TSet`.

### When Does Garbage Collection Occur?

Garbage collection occurs periodically on the game thread, meaning other work that needs to synchronize with the game 
thread must wait while garbage collection occurs. Most of the time garbage collection takes minimal time, but in 
extreme cases garbage collection can cause your game to hitch.

### Can Garbage Collection delete objects while my function is running on the game thread? 

No. Because GC happens on the main thread, it also means that the GC will never delete objects while you hold them, 
because the GC is not running yet when your code is running.

### Can Garbage Collection delete objects while my function is running on a different thread?

Yes. When accessing UObjects on other threads, you must ensure that the object cannot be destroyed while your code is 
running. This can be done using `FGCScopeGuard` which prevents GC from running at all while your code is running, but 
that is inappropriate for long-running code. Instead, modern versions of UE allow you to capture a `TWeakObjectPtr` on 
the game thread, pass it for work on a background thread, and then use `TWeakObjectPtr::Pin()` to obtain a 
`TStrongObjectPtr`, which you can discard when you are done with your work, ensuring that the object remains available 
for the duration you need it, and then is available for destruction by the GC after your work is complete.

### Incremental Garbage Collection

While Unreal's GC is quite efficient, GC hitches can still occur when a lot of UObjects are present, or a lot of them 
are destroyed at once. To address this, newer versions of Unreal include support for "Incremental Garbage Collection". 
This is a very new feature which is not enabled by default, but is expected to be enabled by default in a future Unreal
Engine release.

Incremental garbage collection requires changes to how C++ code interacts with UObjects. With the original design of 
Unreal reflection / GC, no code needed to run when a UObject-derived object is placed into a `UPROPERTY` because the 
garbage collector would do the entire reachability traversal synchronously in the game thread (and modifications to 
UObjects from off thread had to be handled specially to avoid race conditions). 

However incremental garbage collection performs the traversal (usually called the "mark" phase in GC terminology) in 
parts across multiple frames. This means there are a lot more opportunities for gameplay code to change the object 
pointed to by a UPROPERTY while the traversal is ongoing. To ensure that new objects are not marked for destruction in 
the time between their creation and when the objects are placed into UPROPERTY, code needs to be run when the value of 
a `UPROPERTY` is changed.

The solution Epic has introduced for this is `TObjectPtr`. As of Unreal 5.0 it is recommended to use this pointer type
for all reflected properties (those marked with `UPROPERTY`). You should only use this pointer type when declaring such 
properties, and never on the stack or in non-UObject classes and structs (use normal raw pointers there). `TObjectPtr` 
provides automatic implicit conversions to/from raw pointers, including conversions for containers containing 
`TObjectPtr` to/from containers containing raw pointers.

## Explicit Destruction / Auto Nulling

> [!IMPORTANT]
> TLDR: Auto nulling applies to **all objects, not only Actors and Components.**

Unreal supports explicit destruction of an object _in an indirect way_. You can mark an object as garbage (by calling `MarkGarbage()`) even when it is still reachable by living objects, and the garbage collector will modify the known references to that object to be `nullptr` the next time it runs, thus allowing it to collect the object immediately. This functionality can be disabled by setting `gc.GarbageElimination` to `0` (previously known as `gc.PendingKillEnabled`). This is commonly referred to as "auto nulling".

If you read the [Epic documentation](https://dev.epicgames.com/documentation/en-us/unreal-engine/unreal-object-handling-in-unreal-engine?application_version=5.5) 
for Unreal Object Handling you would be forgiven for thinking auto-nulling only occurs for actors and actor components.

> When an **AActor or UActorComponent** is destroyed or otherwise removed from play, all references to it that are 
visible to the reflection system (UProperty pointers and pointers stored in Unreal Engine container classes such as 
TArray) are automatically nulled. This is beneficial in that it prevents dangling pointers from persisting and causing 
trouble down the road, but it also means that **AActor and UActorComponent** pointers can become null if some other 
piece of code destroys them.

> It is important to realize that this feature **applies only to UActorComponent or AActor** references marked with 
> UPROPERTY or stored in an Unreal Engine container class.

The problem with this documentation is that it creates the impression that Unreal's automatic nulling only applies 
to Actors and Components. This is not true. Any UObject can be auto-nulled if its `MarkAsGarbage()` method is called. 
Unfortunately, this documentation, despite being called "Unreal Object Handling" is almost exclusively focused on 
Actors and Components, despite much of its contents applying to UObjects in general. 

If you know that auto-nulling applies to all UObjects which are marked as garbage, you realize that the intended 
emphasis is elsewhere:

> It is important to realize that this feature applies only to [UActorComponent or AActor references] **marked with 
> UPROPERTY** or stored in an Unreal Engine container class.

That is to say, they are trying to describe that auto-nulling doesn't magically locate pointers stored outside of 
UPROPERTY fields, which is true. 


### An Accurate Edit of Epic's Docs
> See below for an edited version of Epic's documentation that removes the misleading phrasing

When a `UObject` (such as `AActor` and `UActorComponent`) instance is destroyed or otherwise removed from play, the 
object is marked as garbage (see `MarkAsGarbage`). All references to it that are visible to the reflection system 
(`UPROPERTY` pointers and pointers stored in Unreal Engine container classes such as `TArray`) are automatically 
nulled. This is beneficial in that it prevents dangling pointers from persisting and causing trouble down the road, 
but it also means that `UObject` pointers can become null if some other piece of code destroys them. The ultimate 
advantage of this is that null-checking is more reliable, as it detects both standard-case null pointers and cases 
where a non-null pointer would have been pointing at deleted memory.

It is important to realize that this feature applies only to pointers stored in fields marked with `UPROPERTY` or 
stored in an Unreal Engine container class (such as `TArray`). A `UObject` pointer stored elsewhere will be unknown 
to the Unreal Engine, and will not be automatically nulled, nor will it prevent garbage collection. Note this does 
not mean that all `UObject*` fields must be marked as `UPROPERTY`. If you want a field that is not marked `UPROPERTY` 
(whether in a `UCLASS` or not), consider using `TWeakObjectPtr`. This is a "weak" pointer, meaning it will not 
prevent garbage collection, but it can be queried for validity before being accessed and will be set to null if 
the Object it points to is destroyed.

Another case where a referenced `UObject` `UPROPERTY` will be automatically null'ed is when using 'Force Delete' on 
an asset in the editor. As a result, all code operating on `UObject` instances which are assets must handle these 
pointers becoming null.

## Outers

When constructing a UObject using `NewObject()`, you can specify an "Outer" object. Outers in Unreal are used for 
various purposes such as serialization (`FPackage` uses it to know whether an object belongs in a package for 
instance), informational ownership (when debugging it can be useful to know what object is the "instigator" in a 
similar manner to the Instigator property of Actors), and allowing the object to retrieve its context without having 
to specify a specific property (for instance an Actor should be able to get its World, and an object "owned" by an 
Actor should be able to get its Actor).

When walking the object graph to find reachable objects, the garbage collector will follow objects' Outers, meaning the Outer is effectively a "strong" GC relationship: A reachable "child" object will keep an otherwise unreachable "outer" object alive. 

The reverse is not true: A reachable Outer object will not keep its "child objects" alive. 

A common misconception is that Outers serve as a way to "group" allocations, that destroying an Outer has the effect of destroying all children, but this is not the case. If you call `MarkGarbage()` on an Outer object, garbage collection of that object will be prevented if there are any reachable "child" objects outstanding. Thus it is not possible for the Outer relationship to be "auto nulled".

## Testing

The conclusions above were gathered with the following test. To try this on your own Unreal Engine, just make a file 
called GCTestActor.h and paste the test. Then, in a test level, add the GCTestActor actor and click the button in the 
Details panel for the test you'd like to run. Each test takes 3 seconds to allow the GC to run (a lot).

The result of the tests are:
- Does auto-nulling apply to all objects: YES
- Does auto-nulling make Outer null: NO
- Does destroying Outer cause child object to be destroyed: NO
- Does a reachable child keep an unreachable outer alive: YES
- Does a reachable outer keep an unreachable child alive: NO

The test code in full:
```cpp
#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "GCTestActor.generated.h"

UCLASS()
class UTestObject: public UObject {
	GENERATED_BODY()
};

UCLASS()
class AGCTestActor : public AActor
{
	GENERATED_BODY()
public:
	UPROPERTY() TObjectPtr<UTestObject> Strong1;
	UPROPERTY() TObjectPtr<UTestObject> Strong2;
	TWeakObjectPtr<UTestObject> Weak1;
	TWeakObjectPtr<UTestObject> Weak2;
	
	// TESTS /////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	UFUNCTION(CallInEditor)
	void Test_ReachableChildUnreachableOuter()
	{
		Test(
			"Does a reachable child keep an unreachable outer alive", 
			[] (auto* Actor) {
				Actor->Weak1 = NewObject<UTestObject>();
				Actor->Strong1 = NewObject<UTestObject>(Actor->Weak1.Get());
			}, 
			[] (auto* Actor) {
				return Actor->Weak1.IsValid();
			}
		);
	}
	
	UFUNCTION(CallInEditor)
	void Test_ReachableOuterUnreachableChild()
	{
		Test(
			"Does a reachable outer keep an unreachable child alive", 
			[] (auto* Actor) {
				Actor->Strong1 = NewObject<UTestObject>();
				Actor->Weak1 = NewObject<UTestObject>(Actor->Strong1.Get());
			}, 
			[] (auto* Actor) {
				return Actor->Weak1.IsValid();
			}
		);
	}
	
	UFUNCTION(CallInEditor)
	void Test_AutoNullingAppliesToAllObjects()
	{
		Test(
			"Does auto-nulling apply to all objects", 
			[] (auto* Actor) {
				Actor->Strong1 = NewObject<UTestObject>();
				Actor->Strong1->MarkAsGarbage();
			}, 
			[] (auto* Actor) {
				return Actor->Strong1 == nullptr;
			}
		);
	}
	
	UFUNCTION(CallInEditor)
	void Test_AutoNullingMakesOutersNull()
	{
		Test(
			"Does auto-nulling make Outer null", 
			[] (auto* Actor) {
				Actor->Strong1 = NewObject<UTestObject>();
				Actor->Strong2 = NewObject<UTestObject>(Actor->Strong1);
				Actor->Strong1->MarkAsGarbage();
			}, 
			[] (auto* Actor) {
				return Actor->Strong2->GetOuter() == nullptr;
			}
		);
	}
	
	UFUNCTION(CallInEditor)
	void Test_DestroyingOuterDestroysChildren()
	{
		Test(
			"Does destroying Outer cause child object to be destroyed", 
			[] (auto* Actor) {
				Actor->Strong1 = NewObject<UTestObject>();
				Actor->Strong2 = NewObject<UTestObject>(Actor->Strong1);
				Actor->Strong1->MarkAsGarbage();
			}, 
			[] (auto* Actor) {
				return Actor->Strong2 == nullptr;
			}
		);
	}
	
private:
	void Test(FString Label, TFunction<void(AGCTestActor*)> Setup, TFunction<bool(AGCTestActor*)> Measurement)
	{
		// Reset
		Strong1 = nullptr;
		Strong2 = nullptr;
		Weak1 = nullptr;
		Weak2 = nullptr;
		
		// Setup the state that should be tested
		Setup(this);
		
		// Aggressively garbage collect
		CollectGarbage(RF_NoFlags);
		IConsoleManager::Get().FindConsoleVariable(TEXT("gc.ForceCollectGarbageEveryFrame"))->Set(1);
		
		// Let garbage collection run, a lot
		Delay(GetWorld(), 3.0f, [this, Label, Measurement]() {
			IConsoleManager::Get().FindConsoleVariable(TEXT("gc.ForceCollectGarbageEveryFrame"))->Set(0);
			
			// Measure and present result
			bool Result = Measurement(this);
			UE_LOGFMT(LogTemp, Log, "[GCTest] {0}: {1}", Label, Result ? "YES" : "NO");
		});
	}
	
	template<typename FunctorType>
	FORCEINLINE FTimerHandle Delay(UWorld *World, float Time, FunctorType Func)
	{
		FTimerHandle Handle;
		World->GetTimerManager().SetTimer(Handle, FTimerDelegate().CreateLambda(Func), Time, false);
		return Handle;
	}
};
```
